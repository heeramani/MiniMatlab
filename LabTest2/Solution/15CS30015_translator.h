#ifndef _TRANSLATOR_H
#define _TRANSLATOR_H

#include <stdio.h>
#include <vector>
#include <cstdlib>
#include <string>
using namespace std;


class symdata; //to enter data into symbol table
class symtab; //usual symbol table

class type_n;// to store a type and its list
class expresn;// to be used for truelist,falselist and nextlist

class funct;
class array;

class quad; //to define quad so that we can further use it to make array
class quad_arr; //it stores the list of quads for the expression and also emits the required emits

//void totest(string x);//to test
struct decStr;
struct idStr;

//
struct arglistStr;
struct expresn;

extern int yyparse();

extern int size_char;
extern int size_bool;

extern int size_double;
extern int size_int;

extern int size_pointer;


//extern variables
extern int glob_width; // to store the global width for inherited attributes

extern int temp_count; // count of the temporary varibles to name the new temporary variable
extern int next_instr; //next instr for use in quads and in different function like backpatch

//global

extern quad_arr glob_quad; //to store all the quads that will be generated by the grammar

extern type_n *glob_type; //to store the global type for inherited attributes
extern symtab *glob_st; //Global symbol table pointer

extern symtab *curr_st; //Current Symbol table pointer

enum types{
	tp_void=0,
	tp_bool,tp_char,
	tp_int,tp_double,
	tp_ptr,
	tp_arr,
	tp_func
};


enum opcode{

	//Binary Assignment Operator
	Q_PLUS=1,Q_MINUS,Q_MULT,Q_DIVIDE,Q_MODULO,Q_OR,Q_XOR,Q_AND,Q_LOG_AND,Q_LOG_OR,Q_LESS_OR_EQUAL,Q_LESS,
	
	
	
	//less

	
	//greater
	
	Q_GREATER,
	
		Q_GREATER_OR_EQUAL,
	
	//equality
	Q_NOT_EQUAL,
	Q_EQUAL,
	
	//left right
	Q_LEFT_OP,
	Q_RIGHT_OP,

	//Unary Operator
	Q_UNARY_PLUS,
	Q_UNARY_MINUS,

	Q_COMPLEMENT,
	Q_NOT,

	//Copy Assignment
	Q_ASSIGN,

	//Unconditional Jump
	Q_GOTO,

	//Conditional Jump
	Q_IF_EQUAL,
	Q_IF_NOT_EQUAL,
	
	Q_IF_GREATER,
	Q_IF_LESS,
	
	
	Q_IF_GREATER_OR_EQUAL,
	Q_IF_LESS_OR_EQUAL,

		Q_IF_EXPRESSION,
	Q_IF_NOT_EXPRESSION,
	

	//Type Conversions
	Q_CHAR2INT,
	Q_CHAR2DOUBLE,
	
	Q_DOUBLE2CHAR,
	Q_INT2DOUBLE,Q_INT2CHAR,Q_DOUBLE2INT,Q_PARAM,Q_RETURN,Q_CALL,Q_ADDR,Q_LDEREF,Q_RDEREF,Q_LINDEX,Q_RINDEX,
};

//it is the basic type that an element can have
union basic_val{
	
	double double_val;
	int int_val;
	char char_val;
};

class type_n{
public:
	types basetp; // to save the basic type of the elemnt
	int size;    // to save the size of the type
	type_n *next; // to save next type_n type for arrays
	type_n(types t,int sz=1, type_n *n=NULL); //constuctor
	
	types getBasetp(); //return Base type
	int getSize(); //returns the size
		
	void print(); 
	void printSize(); //to print the size
};

type_n *CopyType(type_n *t);

class array{
public:

	void addindex(int i);   			//array indexing
	string base_arr;					//Stores the array base and the variable containing array offset
	types tp;							//Initiates array name, offset and array type
	
	vector<int> dims;
	int bsize; 							//base size
	int dimension_size;					//dimensions
	array(string s,int sz,types t);		//array dimension storage

};

typedef struct list{
	struct list *next;
	int index;
	
}list;


class funct{							// To store details of functions, its parameters and return type 
public:
	vector<types> typelist;				//Parameter type list
	type_n *rettype; 					//Return type
	funct(vector<types> tpls);			// Prints details in suitable format
	void print();
};



//class which will be used as building element for symbol table
class symdata
{
public:
	
	int size; //to stoe the size of an element in a symbol table
	int offset;//to maintain the offset at this variable to know the position at symbol table
	string name;//to store the value of a varaible stored in symbol table

	symtab *nest_tab; //to store the pointer to the symbol table to which the current element belongs to
	array *arr;//to store the pointer to an array if its an array type
	
	type_n *tp_n;//for storing the type of element
	
	funct *fun;//to store the pointer to a function if its an function

	basic_val i_val;//to store the initialized value for an element stored at symbol table
	void createarray();
	string var_type;//to store whether the varaible is "null=0" "local=1" "param=2" "func=3" "ret=4" "temporary=5"
	
	bool isFunction; //to know whether the current element is function like function pointer

	bool isInitialized; //If the value of element is initialized or not

	bool isArray; // to know whether the current element is ab array it helps if we have been in grammar tree
	symdata(string n=""); //name is initialized to null that will be used for naming temporary variables
};	

class symtab{
public:
	void update(symdata *loc,type_n *type,basic_val initval, symtab *next = NULL);//
	string name;			// name of the symbol
	int offset;				// final offset of this symbol table that will be used in the update function
	

	vector<symdata*> symbol_tab; //maintaining a list of symbol tables
	symdata* lookup(string n);// Lookup function searches the variable with name. If the variable is present then returns its pointer location else creates a new entry with its name and returns that pointer

	symtab();  //constructor
	~symtab(); //destructor
	symdata* gentemp(type_n *type); //gentemp creates a new element in the symbol table with the type provided at the time of constructing
	symdata* search(string n); //it searches for the variable and returns the oiter to it if present
	
	
	
	void print();
};

// struct for declaration grammar
struct decStr
{
	
	int width;					// width of the variable
	type_n *type;						// type of the current declaration
};

class quad{
public:
	opcode op;
	string arg1,result,arg2; //consist of three elements 
	quad(opcode,string,string,string); //constructorparameters
	void print_arg();
	
};

struct expresn{
	list* falselist;
	type_n* type;
	bool isPointer;
	list* truelist;
	bool isArray;
	symdata *arr;
	symdata* loc;
};
void typecheck(expresn *e1,expresn *e2,bool isAss = false);
list* makelist(int i);  //creates a list have only one element as i
void backpatch(list *l,int i);  //to fill the dangling list of goto's l1 to i
list* merge(list *l1,list *l2); //merges the the two list and return a merged list
void print_list(list *root);
void conv2Bool(expresn *e); //to convert the given exprssion type to bool mostly used in relational operator





struct arglistStr
{
	vector<expresn*> *arguments;		// A simple vector is used to store the locations of all seen arguments
};

// struct for a identifier

struct strstr{
	string name;
	type_n lop;
};

struct idStr{
	string *name;						// identifier
	symdata *loc;						// symboltable pointer
	
};


class quad_arr{
public:
	quad_arr();
	void emit(opcode opc, int val, string operand=""); 
	vector<quad> arr;//to store the list of quads
	void emit(opcode opc, string arg1="", string arg2="", string result="");	//operation with 3 inputs
	 						//integer assignement
	void emit(opcode opc, char val, string operand=""); 
	void emit(opcode opc, double val, string operand=""); 						//double assign
							//char assign 
	
	
	
	void print();  																//quads print
};

#endif
